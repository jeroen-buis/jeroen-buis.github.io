<!doctype html>
<html class="no-js" lang="">
<head>
  <meta charset="utf-8">
  <title>Jeroen's test site</title>
  <meta name="description" content="Testing Glia scripts">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#fafafa">
  <style>
    /* ---------- DENSE THEME ---------- */
    :root{
      --base-font: 13px;
      --mono-font: 11.5px;
      --pad-xxs: 2px;
      --pad-xs: 4px;
      --pad-sm: 6px;
      --gap-xs: 6px;
      --badge-radius: 999px;
      --btn-radius: 6px;
    }

    * { box-sizing: border-box; }
    html body {
      margin: 0;
      background: #fff;
      height: 100%;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: var(--base-font);
      line-height: 1.25;
    }

    h1 { margin: 12px 16px; font-size: 18px; }
    #version { margin: 0 16px 6px; font-size: 11px; color: #666; }

    .toolbar {
      display:flex; gap: 8px; align-items:center;
      margin: 0 16px 6px;
    }

    /* Table (dense) */
    .table-wrap { margin: 0 16px 8px; overflow-x:auto; }
    table { width: 100%; border-collapse: collapse; }
    thead th {
      text-align: left; font-weight: 600;
      border-bottom: 1px solid #ddd;
      padding: var(--pad-xs) var(--pad-sm);
      background:#fafafa; font-size: 12px;
      white-space: nowrap;
    }
    tbody td {
      border-bottom: 1px solid #eee;
      padding: var(--pad-xs) var(--pad-sm);
      vertical-align: middle;
    }
    tbody tr:hover { background:#f9f9f9; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: var(--mono-font); }

    /* Status badges (compact) */
    .status {
      display:inline-block;
      padding: 1px 6px;
      border-radius: var(--badge-radius);
      font-size: 11px; font-weight: 700; color:#fff; text-transform: capitalize;
    }
    .status-open { background:#17a34a; }      /* green */
    .status-closed { background:#dc2626; }    /* red */
    .status-unstaffed, .status-full { background:#ea580c; } /* orange */
    .status-unknown { background:#6b7280; }   /* gray */

    /* Buttons (compact) */
    button {
      padding: 3px 8px;
      border: 1px solid #ddd;
      border-radius: var(--btn-radius);
      background:#fff;
      cursor:pointer;
      font-size: 12px;
    }
    button:hover { background:#f6f6f6; }
    button:disabled { opacity: .45; cursor: not-allowed; }
    .btn-row { display:flex; flex-wrap: wrap; gap: 4px; }

    /* Log (taller for more room) */
    #log {
      margin: 0 16px 12px;
      padding: 8px;
      background:#f1f1f1;
      border:1px solid #ccc;
      height: 320px;             /* was 220px */
      overflow-y: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: var(--mono-font);
    }
    #log p { margin: 0 0 4px; }

    /* Modal (slightly tighter) */
    .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; }
    .modal { width: min(900px, 92vw); max-height: 80vh; background:#fff; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,.25); display:flex; flex-direction:column; }
    .modal-header { display:flex; align-items:center; justify-content:space-between; padding: 8px 10px; border-bottom:1px solid #eee; }
    .modal-body { padding: 0 10px 10px; overflow:auto; }
    .modal-body pre { margin: 8px 0 0; padding:10px; background:#0b1020; color:#e5e7eb; border-radius:8px; font-size: 11.5px; }
    .modal-backdrop.show { display:flex; }

    /* Queuing banner (tight) */
    .banner { margin: 0 16px 8px; padding: 8px 10px; border-radius:8px; background:#fff7ed; border:1px solid #fed7aa; display:none; align-items:center; gap:8px; }
    .banner.show { display:flex; }
    .banner strong { color:#9a3412; font-size: 12px; }
  </style>
</head>
<body>
  <h1>Welcome to Jeroen's test site!</h1>
  <div id="version">Version 1.4.3 (dense)</div>

  <div class="toolbar">
    <button id="refreshBtn" type="button">Refresh queues</button>
    <button id="viewJsonBtn" type="button">View JSON</button>
    <span id="lastUpdated" style="margin-left:auto; font-size:11px; color:#666;"></span>
  </div>

  <div id="queueBanner" class="banner" role="status" aria-live="polite">
    <strong>Queued</strong>
    <span id="queueBannerText" class="mono"></span>
    <button id="cancelQueueBtn" type="button">Cancel</button>
  </div>

  <div class="table-wrap">
    <table id="queuesTable" aria-label="Queues">
      <thead>
        <tr>
          <th>Queue Name</th>
          <th>Queue ID</th>
          <th>Status</th>
          <th>Medias</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- Log -->
  <div id="log"></div>

  <!-- Modal -->
  <div id="jsonModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="jsonTitle">
    <div class="modal">
      <div class="modal-header">
        <strong id="jsonTitle">Queues JSON</strong>
        <button id="closeJsonBtn" type="button" aria-label="Close">Close</button>
      </div>
      <div class="modal-body">
        <pre id="jsonDump" class="mono"></pre>
      </div>
    </div>
  </div>

  <!-- Glia script -->
  <script async
    src="https://api.beta.salemove.com/salemove_integration.js?site_id=4db6b3c1-cb7f-408d-9d8f-ef5d03c0f44b"
    onload="log('salemove_integration.js loaded'); initializeSalemove();">
  </script>

  <script>
    let gliaApi = null;
    let lastQueues = [];
    let queueTicket = null;
    let isEngaged = false;
    let visitorQueueState = 'UNKNOWN'; // 'QUEUED' | 'CANNOT_QUEUE' | 'CAN_QUEUE' | 'UNKNOWN'
    let reenableTimer = null;

    // queueId -> refs
    const rowRefs = new Map();

    /* ---------- utilities ---------- */
    function log(message, data) {
      const logDiv = document.getElementById('log');
      const p = document.createElement('p');
      const suffix = data !== undefined ? ' ' + safeJson(data) : '';
      p.textContent = new Date().toISOString() + ': ' + message + suffix;
      logDiv.appendChild(p);
      logDiv.scrollTop = logDiv.scrollHeight;
    }
    function safeJson(v) { try { return typeof v === 'string' ? v : JSON.stringify(v); } catch { return String(v); } }
    function formatMedias(arr) { if (!Array.isArray(arr) || !arr.length) return '–'; return arr.join(', '); }
    function statusClass(status) {
      switch ((status || '').toLowerCase()) {
        case 'open': return 'status status-open';
        case 'closed': return 'status status-closed';
        case 'unstaffed': return 'status status-unstaffed';
        case 'full': return 'status status-full';
        default: return 'status status-unknown';
      }
    }
    function setLastUpdated() {
      document.getElementById('lastUpdated').textContent = 'Last updated: ' + new Date().toLocaleTimeString();
    }
    function showBanner(text) {
      const b = document.getElementById('queueBanner');
      document.getElementById('queueBannerText').textContent = text || '';
      b.classList.add('show');
    }
    function hideBanner() { document.getElementById('queueBanner').classList.remove('show'); }

    /* ---------- actions ---------- */
    function createActionButtons(q) {
      const container = document.createElement('div');
      container.className = 'btn-row';

      const allowed = new Set((q.state && Array.isArray(q.state.medias)) ? q.state.medias : []);
      const all = ['audio','phone','text','video','messaging'];

      const refs = {};
      all.forEach(m => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = labelForMedium(m);
        btn.disabled = !allowed.has(m) || !isQueueOpen(q); // initial
        btn.addEventListener('click', () => queueForEngagement(q, m));
        container.appendChild(btn);
        refs[m] = btn;
      });

      return { node: container, buttons: refs };
    }

    function labelForMedium(m) {
      switch (m) {
        case 'audio': return 'Start Audio';
        case 'phone': return 'Start Phone';
        case 'text': return 'Start Chat';
        case 'video': return 'Start Video';
        case 'messaging': return 'Start Messaging';
        default: return 'Start ' + m;
      }
    }

    function isQueueOpen(q) {
      return q && q.state && String(q.state.status).toLowerCase() === 'open';
    }

    async function queueForEngagement(q, medium) {
      if (!gliaApi) return;
      try {
        const opts = { queueId: q.id };
        if (medium === 'phone') {
          const num = window.prompt('Enter phone number (E.164, e.g. +11111111111):', '');
          if (!num) { log('Phone queuing canceled by user'); return; }
          opts.phoneNumber = num.trim();
        }
        log('Queueing for engagement...', { queue: q.name, medium });
        const ticket = await gliaApi.queueForEngagement(medium, opts);
        if (ticket && typeof ticket.cancel === 'function') queueTicket = ticket;
      } catch (err) {
        log('Failed to queue: ' + (err?.message || err));
        alert('Failed to queue: ' + (err?.message || err));
      }
    }

    function cancelQueuing() {
      try {
        if (queueTicket && typeof queueTicket.cancel === 'function') {
          queueTicket.cancel();
          log('Requested queue cancel');
        } else {
          log('No direct ticket handle; waiting for state to reflect cancellation');
        }
      } catch (e) {
        log('Cancel error: ' + (e?.message || e));
      }
    }

    /* ---------- renderers ---------- */
    function renderTable(queues) {
      const tbody = document.querySelector('#queuesTable tbody');
      tbody.innerHTML = '';
      rowRefs.clear();

      queues.slice().sort((a,b) => (a.name||'').localeCompare(b.name||'')).forEach(q => {
        const tr = document.createElement('tr');

        const tdName = document.createElement('td');
        tdName.textContent = q.name || '(no name)';
        tr.appendChild(tdName);

        const tdId = document.createElement('td');
        tdId.className = 'mono';
        tdId.textContent = q.id || '';
        tr.appendChild(tdId);

        const tdStatus = document.createElement('td');
        const badge = document.createElement('span');
        const status = (q.state && q.state.status) ? q.state.status : 'unknown';
        badge.className = statusClass(status);
        badge.textContent = status;
        tdStatus.appendChild(badge);
        tr.appendChild(tdStatus);

        const tdMedias = document.createElement('td');
        tdMedias.textContent = formatMedias(q.state && q.state.medias);
        tr.appendChild(tdMedias);

        const tdActions = document.createElement('td');
        const actions = createActionButtons(q);
        tdActions.appendChild(actions.node);
        tr.appendChild(tdActions);

        tbody.appendChild(tr);

        rowRefs.set(q.id, {
          row: tr,
          statusBadge: badge,
          actionButtons: actions.buttons
        });
      });
      setLastUpdated();

      queues.forEach(updateRowFromQueueState);
    }

    function updateRowFromQueueState(q) {
      const ref = rowRefs.get(q.id);
      if (!ref) return;

      const status = (q.state && q.state.status) ? q.state.status : 'unknown';
      ref.statusBadge.className = statusClass(status);
      ref.statusBadge.textContent = status;

      // block only when actually engaged or queued
      const allowed = new Set((q.state && Array.isArray(q.state.medias)) ? q.state.medias : []);
      const open = isQueueOpen(q);
      const globallyBlocked = isEngaged || visitorQueueState === 'QUEUED';

      Object.entries(ref.actionButtons).forEach(([medium, btn]) => {
        btn.disabled = !open || !allowed.has(medium) || globallyBlocked;
      });
    }

    function renderJsonModal() {
      document.getElementById('jsonDump').textContent = JSON.stringify(lastQueues, null, 2);
    }

    function forceEnableAllRows() {
      lastQueues.forEach(q => {
        const ref = rowRefs.get(q.id);
        if (!ref) return;
        const allowed = new Set((q.state && Array.isArray(q.state.medias)) ? q.state.medias : []);
        const open = isQueueOpen(q);
        Object.entries(ref.actionButtons).forEach(([medium, btn]) => {
          btn.disabled = !(open && allowed.has(medium));
        });
      });
      log('Force-enabled action buttons based on queue openness');
    }

    /* ---------- data flow ---------- */
    function refreshQueues() {
      if (!gliaApi) return Promise.resolve();
      return gliaApi.getQueues().then(queues => {
        lastQueues = queues || [];
        renderTable(lastQueues);
        log('Queues refreshed (' + lastQueues.length + ')');

        const ids = lastQueues.map(q => q.id);
        if (typeof gliaApi.subscribeToQueueStateUpdates === 'function') {
          gliaApi.subscribeToQueueStateUpdates(ids, onQueueState);
        }
      }).catch(err => {
        log('getQueues() failed: ' + (err && err.message ? err.message : err));
      });
    }

    function onQueueState(queue) {
      updateRowFromQueueState(queue);
    }

    /* ---------- state listeners ---------- */
    function onVisitorQueueingState(queuingState) {
      try {
        const state = queuingState?.state || '';
        if (state === queuingState.QUEUE_STATES.QUEUED) {
          visitorQueueState = 'QUEUED';
          queueTicket = queuingState.ticket || queueTicket;
          showBanner(`You are queued (reason: ${queuingState?.transitionReason || 'n/a'})`);
          rowRefs.forEach(ref => Object.values(ref.actionButtons).forEach(btn => btn.disabled = true));
        } else if (state === queuingState.QUEUE_STATES.CANNOT_QUEUE) {
          visitorQueueState = 'CANNOT_QUEUE';
          queueTicket = null;
          hideBanner();
          // don't globally disable; let row state decide
          lastQueues.forEach(updateRowFromQueueState);
        } else {
          visitorQueueState = 'CAN_QUEUE';
          queueTicket = null;
          hideBanner();
          lastQueues.forEach(updateRowFromQueueState);
        }
      } catch (e) {
        log('Error handling visitor queueing state: ' + (e?.message || e));
      }
    }

    function onEngagementStart(e) {
      isEngaged = true;
      log('ENGAGEMENT_START');
      rowRefs.forEach(ref => Object.values(ref.actionButtons).forEach(btn => btn.disabled = true));
    }

    function onEngagementEnd(e) {
      isEngaged = false;
      visitorQueueState = 'CAN_QUEUE';
      queueTicket = null;
      hideBanner();
      log('ENGAGEMENT_END — enabling buttons and refreshing queues');

      if (reenableTimer) clearTimeout(reenableTimer);
      reenableTimer = setTimeout(async () => {
        await refreshQueues();
        forceEnableAllRows();
        setTimeout(forceEnableAllRows, 800); // safety pass
      }, 300);
    }

    function attachGlobalListeners(glia) {
      glia.addEventListener(glia.EVENTS.QUEUE_STATE_UPDATE, onVisitorQueueingState);
      glia.addEventListener(glia.EVENTS.ENGAGEMENT_START, onEngagementStart);
      glia.addEventListener(glia.EVENTS.ENGAGEMENT_END, onEngagementEnd);
    }

    /* ---------- modal + DOM controls ---------- */
    function openJsonModal() { renderJsonModal(); document.getElementById('jsonModal').classList.add('show'); }
    function closeJsonModal() { document.getElementById('jsonModal').classList.remove('show'); }

    /* ---------- init ---------- */
    function initializeSalemove() {
      if (typeof sm !== 'undefined' && typeof sm.getApi === 'function') {
        sm.getApi({ version: 'v1' }).then(function(glia) {
          gliaApi = glia;
          log('Salemove API initialized.');

          attachGlobalListeners(glia);
          refreshQueues();

          glia.updateInformation({
            customAttributesUpdateMethod: 'merge',
            customAttributes: { vip: 'true' }
          }).then(function() {
            log('Visitor info updated (customAttributes.vip=true).');
          }).catch(function(error) {
            if (error.cause === glia.ERRORS.NETWORK_TIMEOUT) {
              log('Error: Network timeout while updating visitor info.');
            } else {
              log('Error updating visitor info: ' + error.message);
            }
          });

        }).catch(function(error) {
          log('Error initializing Salemove API: ' + error.message);
        });
      } else {
        log('Salemove API (sm object) not available.');
      }
    }

    window.addEventListener('DOMContentLoaded', function() {
      log('Page fully loaded and DOM is ready.');

      document.getElementById('refreshBtn').addEventListener('click', refreshQueues);
      document.getElementById('viewJsonBtn').addEventListener('click', openJsonModal);
      document.getElementById('closeJsonBtn').addEventListener('click', closeJsonModal);
      document.getElementById('jsonModal').addEventListener('click', (e) => { if (e.target.id === 'jsonModal') closeJsonModal(); });
      window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeJsonModal(); });

      document.getElementById('cancelQueueBtn').addEventListener('click', cancelQueuing);
    });
  </script>
</body>
</html>
