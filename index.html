<!doctype html>
<html class="no-js" lang="">
<head>
  <meta charset="utf-8">
  <title>Jeroen's test site</title>
  <meta name="description" content="Testing Glia scripts">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#fafafa">
  <style>
    * { box-sizing: border-box; }
    html body { margin: 0; background: #fff; height: 100%; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }

    h1 { margin: 20px; }
    #version { margin: 0 20px 10px; font-size: 12px; color: #666; }
    .toolbar { display:flex; gap:10px; align-items:center; margin: 0 20px 10px; }

    /* Table */
    .table-wrap { margin: 0 20px 20px; overflow-x:auto; }
    table { width: 100%; border-collapse: collapse; }
    thead th { text-align: left; font-weight: 600; border-bottom: 2px solid #ddd; padding: 10px 8px; background:#fafafa; }
    tbody td { border-bottom: 1px solid #eee; padding: 8px; vertical-align: top; }
    tbody tr:hover { background:#f9f9f9; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; }

    /* Status badges */
    .status { display:inline-block; padding: 2px 8px; border-radius: 999px; font-size: 12px; font-weight: 600; color:#fff; text-transform: capitalize; }
    .status-open { background:#17a34a; }      /* green */
    .status-closed { background:#dc2626; }    /* red */
    .status-unstaffed, .status-full { background:#ea580c; } /* orange */
    .status-unknown { background:#6b7280; }   /* gray */

    /* Log */
    #log { margin: 0 20px 20px; padding: 10px; background:#f1f1f1; border:1px solid #ccc;
           height: 220px; overflow-y: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    #log p { margin: 0 0 6px; }

    /* Buttons */
    button { padding: 6px 10px; border: 1px solid #ddd; border-radius: 8px; background:#fff; cursor:pointer; }
    button:hover { background:#f6f6f6; }
    button:disabled { opacity: .45; cursor: not-allowed; }
    .btn-row { display:flex; flex-wrap: wrap; gap:6px; }

    /* Modal */
    .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; }
    .modal { width: min(920px, 92vw); max-height: 82vh; background:#fff; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,.25); display:flex; flex-direction:column; }
    .modal-header { display:flex; align-items:center; justify-content:space-between; padding: 12px 14px; border-bottom:1px solid #eee; }
    .modal-body { padding: 0 14px 14px; overflow:auto; }
    .modal-body pre { margin: 12px 0 0; padding:12px; background:#0b1020; color:#e5e7eb; border-radius:8px; }
    .modal-backdrop.show { display:flex; }

    /* Queuing banner */
    .banner { margin: 0 20px 14px; padding:10px 12px; border-radius:10px; background:#fff7ed; border:1px solid #fed7aa; display:none; align-items:center; gap:10px; }
    .banner.show { display:flex; }
    .banner strong { color:#9a3412; }
  </style>
</head>
<body>
  <h1>Welcome to Jeroen's test site!</h1>
  <div id="version">Version 1.3.0</div>

  <div class="toolbar">
    <button id="refreshBtn" type="button">Refresh queues</button>
    <button id="viewJsonBtn" type="button">View JSON</button>
    <span id="lastUpdated" style="margin-left:auto; font-size:12px; color:#666;"></span>
  </div>

  <div id="queueBanner" class="banner" role="status" aria-live="polite">
    <strong>Queued</strong>
    <span id="queueBannerText" class="mono"></span>
    <button id="cancelQueueBtn" type="button">Cancel queuing</button>
  </div>

  <div class="table-wrap">
    <table id="queuesTable" aria-label="Queues">
      <thead>
        <tr>
          <th>Queue Name</th>
          <th>Queue ID</th>
          <th>Status</th>
          <th>Medias</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        <!-- rows injected here -->
      </tbody>
    </table>
  </div>

  <!-- Log (kept for debugging) -->
  <div id="log"></div>

  <!-- Modal -->
  <div id="jsonModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="jsonTitle">
    <div class="modal">
      <div class="modal-header">
        <strong id="jsonTitle">Queues JSON</strong>
        <button id="closeJsonBtn" type="button" aria-label="Close">Close</button>
      </div>
      <div class="modal-body">
        <pre id="jsonDump" class="mono"></pre>
      </div>
    </div>
  </div>

  <!-- Glia script -->
  <script async
    src="https://api.beta.salemove.com/salemove_integration.js?site_id=4db6b3c1-cb7f-408d-9d8f-ef5d03c0f44b"
    onload="log('salemove_integration.js loaded'); initializeSalemove();">
  </script>

  <script>
    let gliaApi = null;
    let lastQueues = [];
    let queueTicket = null;

    // map: queueId -> { row, statusBadge, actionButtons: { audio, phone, text, video, messaging } }
    const rowRefs = new Map();

    /* ---------- utilities ---------- */
    function log(message, data) {
      const logDiv = document.getElementById('log');
      const p = document.createElement('p');
      const suffix = data !== undefined ? ' ' + safeJson(data) : '';
      p.textContent = new Date().toISOString() + ': ' + message + suffix;
      logDiv.appendChild(p);
      logDiv.scrollTop = logDiv.scrollHeight;
    }
    function safeJson(v) { try { return typeof v === 'string' ? v : JSON.stringify(v); } catch { return String(v); } }
    function formatMedias(arr) { if (!Array.isArray(arr) || !arr.length) return '–'; return arr.join(', '); }
    function statusClass(status) {
      switch ((status || '').toLowerCase()) {
        case 'open': return 'status status-open';
        case 'closed': return 'status status-closed';
        case 'unstaffed': return 'status status-unstaffed';
        case 'full': return 'status status-full';
        default: return 'status status-unknown';
      }
    }
    function setLastUpdated() {
      document.getElementById('lastUpdated').textContent = 'Last updated: ' + new Date().toLocaleTimeString();
    }
    function showBanner(text) {
      const b = document.getElementById('queueBanner');
      document.getElementById('queueBannerText').textContent = text || '';
      b.classList.add('show');
    }
    function hideBanner() { document.getElementById('queueBanner').classList.remove('show'); }

    /* ---------- actions ---------- */
    function createActionButtons(q) {
      const container = document.createElement('div');
      container.className = 'btn-row';

      const allowed = new Set((q.state && Array.isArray(q.state.medias)) ? q.state.medias : []);
      const all = ['audio','phone','text','video','messaging'];

      const refs = {};
      all.forEach(m => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = labelForMedium(m);
        btn.disabled = !allowed.has(m) || !isQueueOpen(q);
        btn.addEventListener('click', () => queueForEngagement(q, m));
        container.appendChild(btn);
        refs[m] = btn;
      });

      return { node: container, buttons: refs };
    }

    function labelForMedium(m) {
      switch (m) {
        case 'audio': return 'Start Audio';
        case 'phone': return 'Start Phone';
        case 'text': return 'Start Chat';
        case 'video': return 'Start Video';
        case 'messaging': return 'Start Messaging';
        default: return 'Start ' + m;
      }
    }

    function isQueueOpen(q) {
      return q && q.state && String(q.state.status).toLowerCase() === 'open';
    }

    async function queueForEngagement(q, medium) {
      if (!gliaApi) return;
      try {
        const opts = { queueId: q.id };
        if (medium === 'phone') {
          const num = window.prompt('Enter phone number (E.164, e.g. +11111111111):', '');
          if (!num) { log('Phone queuing canceled by user'); return; }
          opts.phoneNumber = num.trim();
        }
        log('Queueing for engagement...', { queue: q.name, medium });
        const ticket = await gliaApi.queueForEngagement(medium, opts);
        // Some SDKs return a ticket only via state; we keep local too if available.
        if (ticket && typeof ticket.cancel === 'function') queueTicket = ticket;
      } catch (err) {
        log('Failed to queue: ' + (err?.message || err));
        alert('Failed to queue: ' + (err?.message || err));
      }
    }

    function cancelQueuing() {
      try {
        if (queueTicket && typeof queueTicket.cancel === 'function') {
          queueTicket.cancel();
          log('Requested queue cancel');
        } else {
          // If we don't have a direct ticket handle, still try the API helper if available in your SDK version.
          log('No direct ticket handle; waiting for state to reflect cancellation');
        }
      } catch (e) {
        log('Cancel error: ' + (e?.message || e));
      }
    }

    /* ---------- renderers ---------- */
    function renderTable(queues) {
      const tbody = document.querySelector('#queuesTable tbody');
      tbody.innerHTML = '';
      rowRefs.clear();

      queues.slice().sort((a,b) => (a.name||'').localeCompare(b.name||'')).forEach(q => {
        const tr = document.createElement('tr');

        const tdName = document.createElement('td');
        tdName.textContent = q.name || '(no name)';
        tr.appendChild(tdName);

        const tdId = document.createElement('td');
        tdId.className = 'mono';
        tdId.textContent = q.id || '';
        tr.appendChild(tdId);

        const tdStatus = document.createElement('td');
        const badge = document.createElement('span');
        const status = (q.state && q.state.status) ? q.state.status : 'unknown';
        badge.className = statusClass(status);
        badge.textContent = status;
        tdStatus.appendChild(badge);
        tr.appendChild(tdStatus);

        const tdMedias = document.createElement('td');
        tdMedias.textContent = formatMedias(q.state && q.state.medias);
        tr.appendChild(tdMedias);

        const tdActions = document.createElement('td');
        const actions = createActionButtons(q);
        tdActions.appendChild(actions.node);
        tr.appendChild(tdActions);

        tbody.appendChild(tr);

        rowRefs.set(q.id, {
          row: tr,
          statusBadge: badge,
          actionButtons: actions.buttons
        });
      });
      setLastUpdated();
    }

    function updateRowFromQueueState(q) {
      const ref = rowRefs.get(q.id);
      if (!ref) return;

      // status badge
      const status = (q.state && q.state.status) ? q.state.status : 'unknown';
      ref.statusBadge.className = statusClass(status);
      ref.statusBadge.textContent = status;

      // enable/disable media buttons
      const allowed = new Set((q.state && Array.isArray(q.state.medias)) ? q.state.medias : []);
      const open = isQueueOpen(q);
      Object.entries(ref.actionButtons).forEach(([medium, btn]) => {
        btn.disabled = !open || !allowed.has(medium) || !!queueTicket; // disable if queued
      });
    }

    function enableDisableAllActions(disabled) {
      rowRefs.forEach(ref => {
        Object.values(ref.actionButtons).forEach(btn => { btn.disabled = disabled ? true : btn.disabled; });
      });
    }

    function renderJsonModal() {
      document.getElementById('jsonDump').textContent = JSON.stringify(lastQueues, null, 2);
    }

    /* ---------- data flow ---------- */
    function refreshQueues() {
      if (!gliaApi) return;
      return gliaApi.getQueues().then(queues => {
        lastQueues = queues || [];
        renderTable(lastQueues);
        log('Queues refreshed (' + lastQueues.length + ')');

        // Subscribe per-queue state changes (re-subscribe on refresh)
        const ids = lastQueues.map(q => q.id);
        if (typeof gliaApi.subscribeToQueueStateUpdates === 'function') {
          gliaApi.subscribeToQueueStateUpdates(ids, onQueueState);
        }
      }).catch(err => {
        log('getQueues() failed: ' + (err && err.message ? err.message : err));
      });
    }

    function onQueueState(queue) {
      // Called for specific queue updates
      updateRowFromQueueState(queue);
    }

    // Visitor-level queueing state (QUEUED / CAN_QUEUE / CANNOT_QUEUE etc.)
    function onVisitorQueueingState(queuingState) {
      try {
        const state = queuingState?.state || '';
        if (state === queuingState.QUEUE_STATES.QUEUED) {
          queueTicket = queuingState.ticket || queueTicket;
          showBanner(`You are queued (reason: ${queuingState?.transitionReason || 'n/a'})`);
          // disable all action buttons while queued
          rowRefs.forEach(ref => Object.values(ref.actionButtons).forEach(btn => btn.disabled = true));
        } else if (state === queuingState.QUEUE_STATES.CANNOT_QUEUE) {
          queueTicket = null;
          hideBanner();
          // disable all actions; user cannot queue right now
          rowRefs.forEach(ref => Object.values(ref.actionButtons).forEach(btn => btn.disabled = true));
        } else {
          // can queue
          queueTicket = null;
          hideBanner();
          // re-enable based on each queue's open/medias
          lastQueues.forEach(updateRowFromQueueState);
        }
      } catch (e) {
        log('Error handling visitor queueing state: ' + (e?.message || e));
      }
    }

    function attachGlobalListeners(glia) {
      // Listen for visitor’s queueing state updates
      glia.addEventListener(glia.EVENTS.QUEUE_STATE_UPDATE, onVisitorQueueingState);
    }

    /* ---------- modal + DOM controls ---------- */
    function openJsonModal() { renderJsonModal(); document.getElementById('jsonModal').classList.add('show'); }
    function closeJsonModal() { document.getElementById('jsonModal').classList.remove('show'); }

    /* ---------- init ---------- */
    function initializeSalemove() {
      if (typeof sm !== 'undefined' && typeof sm.getApi === 'function') {
        sm.getApi({ version: 'v1' }).then(function(glia) {
          gliaApi = glia;
          log('Salemove API initialized.');

          attachGlobalListeners(glia);
          refreshQueues();

          // example: set a custom attribute
          glia.updateInformation({
            customAttributesUpdateMethod: 'merge',
            customAttributes: { vip: 'true' }
          }).then(function() {
            log('Visitor info updated (customAttributes.vip=true).');
          }).catch(function(error) {
            if (error.cause === glia.ERRORS.NETWORK_TIMEOUT) {
              log('Error: Network timeout while updating visitor info.');
            } else {
              log('Error updating visitor info: ' + error.message);
            }
          });

        }).catch(function(error) {
          log('Error initializing Salemove API: ' + error.message);
        });
      } else {
        log('Salemove API (sm object) not available.');
      }
    }

    window.addEventListener('DOMContentLoaded', function() {
      log('Page fully loaded and DOM is ready.');

      document.getElementById('refreshBtn').addEventListener('click', refreshQueues);
      document.getElementById('viewJsonBtn').addEventListener('click', openJsonModal);
      document.getElementById('closeJsonBtn').addEventListener('click', closeJsonModal);
      document.getElementById('jsonModal').addEventListener('click', (e) => { if (e.target.id === 'jsonModal') closeJsonModal(); });
      window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeJsonModal(); });

      document.getElementById('cancelQueueBtn').addEventListener('click', cancelQueuing);
    });
  </script>
</body>
</html>
