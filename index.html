<!doctype html>
<html class="no-js" lang="">
<head>
  <meta charset="utf-8">
  <title>Jeroen's test site</title>
  <meta name="description" content="Testing Glia scripts">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#fafafa">
  <style>
    /* ---------- DENSE THEME ---------- */
    :root{
      --base-font: 13px;
      --mono-font: 11.5px;
      --pad-xxs: 2px;
      --pad-xs: 4px;
      --pad-sm: 6px;
      --gap-xs: 6px;
      --badge-radius: 999px;
      --btn-radius: 6px;
    }

    * { box-sizing: border-box; }
    html body {
      margin: 0; background: #fff; height: 100%;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: var(--base-font); line-height: 1.25;
    }

    h1 { margin: 12px 16px; font-size: 18px; }
    #version { margin: 0 16px 6px; font-size: 11px; color: #666; }

    .toolbar { display:flex; gap: 8px; align-items:center; margin: 0 16px 6px; }
    .toolbar small { color:#666; }

    /* ---------- LAYOUT: 2/3 table + 1/3 attributes ---------- */
    .content {
      display: grid;
      grid-template-columns: 2fr 1fr;      /* 2/3 + 1/3 */
      gap: 10px;
      margin: 0 16px 8px;
      align-items: start;
    }

    /* Table (dense) */
    .table-wrap { overflow-x:auto; }
    table { width: 100%; border-collapse: collapse; }
    thead th {
      text-align: left; font-weight: 600;
      border-bottom: 1px solid #ddd;
      padding: var(--pad-xs) var(--pad-sm);
      background:#fafafa; font-size: 12px; white-space: nowrap;
    }
    tbody td {
      border-bottom: 1px solid #eee;
      padding: var(--pad-xs) var(--pad-sm);
      vertical-align: middle;
    }
    tbody tr:hover { background:#f9f9f9; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: var(--mono-font); }

    /* Status badges (compact) */
    .status {
      display:inline-block; padding: 1px 6px;
      border-radius: var(--badge-radius); font-size: 11px; font-weight: 700;
      color:#fff; text-transform: capitalize;
    }
    .status-open { background:#17a34a; }      /* green */
    .status-closed { background:#dc2626; }    /* red */
    .status-unstaffed, .status-full { background:#ea580c; } /* orange */
    .status-unknown { background:#6b7280; }   /* gray */

    /* Buttons (compact) */
    button {
      padding: 3px 8px; border: 1px solid #ddd; border-radius: var(--btn-radius);
      background:#fff; cursor:pointer; font-size: 12px;
    }
    button:hover { background:#f6f6f6; }
    button:disabled { opacity: .45; cursor: not-allowed; }
    .btn-row { display:flex; flex-wrap: wrap; gap: 4px; }

    /* Attributes panel */
    .card {
      border: 1px solid #e5e7eb; border-radius: 10px; padding: 10px;
      background: #fff;
    }
    .card h2 { margin: 0 0 8px; font-size: 14px; }
    .field { display:flex; flex-direction:column; gap:4px; margin-bottom: 8px; }
    .field label { font-size: 11.5px; color:#374151; }
    .field input {
      padding: 6px 8px; border:1px solid #d1d5db; border-radius: 6px;
      font-size: 12px;
    }
    .field input::placeholder { color:#9ca3af; }
    .actions { display:flex; gap:6px; }
    .hint { margin: 6px 0 0; font-size: 11px; color:#6b7280; }
    .json-mini { margin-top: 8px; font-size: 11.5px; background:#0b1020; color:#e5e7eb; padding:8px; border-radius:8px; max-height:140px; overflow:auto; }

    /* Log (taller for more room) */
    #log {
      margin: 0 16px 12px; padding: 8px;
      background:#f1f1f1; border:1px solid #ccc;
      height: 340px; overflow-y: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: var(--mono-font);
    }
    #log p { margin: 0 0 4px; }

    /* Modal (slightly tighter) */
    .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; }
    .modal { width: min(900px, 92vw); max-height: 80vh; background:#fff; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,.25); display:flex; flex-direction:column; }
    .modal-header { display:flex; align-items:center; justify-content:space-between; padding: 8px 10px; border-bottom:1px solid #eee; }
    .modal-body { padding: 0 10px 10px; overflow:auto; }
    .modal-body pre { margin: 8px 0 0; padding:10px; background:#0b1020; color:#e5e7eb; border-radius:8px; font-size: 11.5px; }
    .modal-backdrop.show { display:flex; }

    /* Queuing banner (tight) */
    .banner { margin: 0 16px 8px; padding: 8px 10px; border-radius:8px; background:#fff7ed; border:1px solid #fed7aa; display:none; align-items:center; gap:8px; }
    .banner.show { display:flex; }
    .banner strong { color:#9a3412; font-size: 12px; }

    @media (max-width: 980px){
      .content { grid-template-columns: 1fr; } /* stack on small screens */
    }
  </style>
</head>
<body>
  <h1>Welcome to Jeroen's test site!</h1>
  <div id="version">Version 1.5.0 (dense + attributes)</div>

  <div class="toolbar">
    <button id="refreshBtn" type="button">Refresh queues</button>
    <button id="viewJsonBtn" type="button">View JSON</button>
    <span id="lastUpdated" style="margin-left:auto;"><small></small></span>
  </div>

  <div id="queueBanner" class="banner" role="status" aria-live="polite">
    <strong>Queued</strong>
    <span id="queueBannerText" class="mono"></span>
    <button id="cancelQueueBtn" type="button">Cancel</button>
  </div>

  <!-- 2/3 + 1/3 area -->
  <div class="content">
    <!-- Left: Queues table -->
    <div class="table-wrap">
      <table id="queuesTable" aria-label="Queues">
        <thead>
          <tr>
            <th>Queue Name</th>
            <th>Queue ID</th>
            <th>Status</th>
            <th>Medias</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- Right: Attributes panel -->
    <aside class="card">
      <h2>Visitor Attributes</h2>
      <div class="field">
        <label for="attr_name">visitor_name</label>
        <input id="attr_name" type="text" placeholder="e.g. John Smith">
      </div>
      <div class="field">
        <label for="attr_pref_name">visitor_preferred_name</label>
        <input id="attr_pref_name" type="text" placeholder="e.g. John">
      </div>
      <div class="field">
        <label for="attr_email">visitor_email</label>
        <input id="attr_email" type="email" placeholder="e.g. john.smith@example.com">
      </div>
      <div class="field">
        <label for="attr_subject">subject</label>
        <input id="attr_subject" type="text" placeholder="e.g. john.smith">
      </div>
      <div class="actions">
        <button id="saveAttrsBtn" type="button">Save attributes</button>
        <button id="resetAttrsBtn" type="button">Reset fields</button>
      </div>
      <p class="hint">
        Saving will <em>merge</em> these into Glia custom attributes and cache them in this browser.
      </p>
      <pre id="attrsPreview" class="json-mini mono">{}</pre>
    </aside>
  </div>

  <!-- Log -->
  <div id="log"></div>

  <!-- Modal -->
  <div id="jsonModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="jsonTitle">
    <div class="modal">
      <div class="modal-header">
        <strong id="jsonTitle">Queues JSON</strong>
        <button id="closeJsonBtn" type="button" aria-label="Close">Close</button>
      </div>
      <div class="modal-body">
        <pre id="jsonDump" class="mono"></pre>
      </div>
    </div>
  </div>

  <!-- Glia script -->
  <script async
    src="https://api.beta.salemove.com/salemove_integration.js?site_id=4db6b3c1-cb7f-408d-9d8f-ef5d03c0f44b"
    onload="log('salemove_integration.js loaded'); initializeSalemove();">
  </script>

  <script>
    let gliaApi = null;
    let lastQueues = [];
    let queueTicket = null;
    let isEngaged = false;
    let visitorQueueState = 'UNKNOWN'; // 'QUEUED' | 'CANNOT_QUEUE' | 'CAN_QUEUE' | 'UNKNOWN'
    let reenableTimer = null;

    // queueId -> refs
    const rowRefs = new Map();
    const ATTRS_STORAGE_KEY = 'glia_custom_attrs_demo_v1';

    /* ---------- utilities ---------- */
    function log(message, data) {
      const logDiv = document.getElementById('log');
      const p = document.createElement('p');
      const suffix = data !== undefined ? ' ' + safeJson(data) : '';
      p.textContent = new Date().toISOString() + ': ' + message + suffix;
      logDiv.appendChild(p);
      logDiv.scrollTop = logDiv.scrollHeight;
    }
    function safeJson(v) { try { return typeof v === 'string' ? v : JSON.stringify(v); } catch { return String(v); } }
    function formatMedias(arr) { if (!Array.isArray(arr) || !arr.length) return '–'; return arr.join(', '); }
    function statusClass(status) {
      switch ((status || '').toLowerCase()) {
        case 'open': return 'status status-open';
        case 'closed': return 'status status-closed';
        case 'unstaffed': return 'status status-unstaffed';
        case 'full': return 'status status-full';
        default: return 'status status-unknown';
      }
    }
    function setLastUpdated() {
      document.querySelector('#lastUpdated small').textContent = 'Last updated: ' + new Date().toLocaleTimeString();
    }

    function showBanner(text) {
      const b = document.getElementById('queueBanner');
      document.getElementById('queueBannerText').textContent = text || '';
      b.classList.add('show');
    }
    function hideBanner() { document.getElementById('queueBanner').classList.remove('show'); }

    /* ---------- attributes panel ---------- */
    function loadAttrsFromStorage() {
      try { return JSON.parse(localStorage.getItem(ATTRS_STORAGE_KEY) || '{}'); }
      catch { return {}; }
    }
    function saveAttrsToStorage(obj) {
      localStorage.setItem(ATTRS_STORAGE_KEY, JSON.stringify(obj || {}));
    }
    function readAttrsFromForm() {
      return {
        visitor_name: document.getElementById('attr_name').value.trim(),
        visitor_preferred_name: document.getElementById('attr_pref_name').value.trim(),
        visitor_email: document.getElementById('attr_email').value.trim(),
        subject: document.getElementById('attr_subject').value.trim()
      };
    }
    function writeAttrsToForm(attrs) {
      document.getElementById('attr_name').value = attrs.visitor_name || '';
      document.getElementById('attr_pref_name').value = attrs.visitor_preferred_name || '';
      document.getElementById('attr_email').value = attrs.visitor_email || '';
      document.getElementById('attr_subject').value = attrs.subject || '';
      renderAttrsPreview(attrs);
    }
    function renderAttrsPreview(attrs) {
      document.getElementById('attrsPreview').textContent = JSON.stringify(attrs || {}, null, 2);
    }

    async function saveAttributesToGlia() {
      if (!gliaApi) { alert('Glia not ready'); return; }
      const attrs = readAttrsFromForm();
      // Build payload with only non-empty keys (avoid overwriting with empty strings)
      const payload = {};
      Object.entries(attrs).forEach(([k,v]) => { if (v !== '') payload[k] = v; });
      if (Object.keys(payload).length === 0) {
        log('No attributes to save (all empty)');
        return;
      }
      try {
        await gliaApi.updateInformation({
          customAttributesUpdateMethod: 'merge',
          customAttributes: payload
        });
        log('Saved custom attributes', payload);
        saveAttrsToStorage(attrs);
        renderAttrsPreview(attrs);
      } catch (err) {
        log('Failed to save attributes: ' + (err?.message || err));
        alert('Failed to save attributes: ' + (err?.message || err));
      }
    }

    function resetAttributesForm() {
      writeAttrsToForm({});
      saveAttrsToStorage({});
      log('Cleared local attribute fields');
    }

    /* ---------- actions ---------- */
    function createActionButtons(q) {
      const container = document.createElement('div');
      container.className = 'btn-row';

      const allowed = new Set((q.state && Array.isArray(q.state.medias)) ? q.state.medias : []);
      const all = ['audio','phone','text','video','messaging'];

      const refs = {};
      all.forEach(m => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = labelForMedium(m);
        btn.disabled = !allowed.has(m) || !isQueueOpen(q);
        btn.addEventListener('click', () => queueForEngagement(q, m));
        container.appendChild(btn);
        refs[m] = btn;
      });

      return { node: container, buttons: refs };
    }

    function labelForMedium(m) {
      switch (m) {
        case 'audio': return 'Start Audio';
        case 'phone': return 'Start Phone';
        case 'text': return 'Start Chat';
        case 'video': return 'Start Video';
        case 'messaging': return 'Start Messaging';
        default: return 'Start ' + m;
      }
    }

    function isQueueOpen(q) {
      return q && q.state && String(q.state.status).toLowerCase() === 'open';
    }

    async function queueForEngagement(q, medium) {
      if (!gliaApi) return;
      try {
        const opts = { queueId: q.id };
        if (medium === 'phone') {
          const num = window.prompt('Enter phone number (E.164, e.g. +11111111111):', '');
          if (!num) { log('Phone queuing canceled by user'); return; }
          opts.phoneNumber = num.trim();
        }
        log('Queueing for engagement...', { queue: q.name, medium });
        const ticket = await gliaApi.queueForEngagement(medium, opts);
        if (ticket && typeof ticket.cancel === 'function') queueTicket = ticket;
      } catch (err) {
        log('Failed to queue: ' + (err?.message || err));
        alert('Failed to queue: ' + (err?.message || err));
      }
    }

    function cancelQueuing() {
      try {
        if (queueTicket && typeof queueTicket.cancel === 'function') {
          queueTicket.cancel();
          log('Requested queue cancel');
        } else {
          log('No direct ticket handle; waiting for state to reflect cancellation');
        }
      } catch (e) {
        log('Cancel error: ' + (e?.message || e));
      }
    }

    /* ---------- renderers ---------- */
    function renderTable(queues) {
      const tbody = document.querySelector('#queuesTable tbody');
      tbody.innerHTML = '';
      rowRefs.clear();

      queues.slice().sort((a,b) => (a.name||'').localeCompare(b.name||'')).forEach(q => {
        const tr = document.createElement('tr');

        const tdName = document.createElement('td');
        tdName.textContent = q.name || '(no name)';
        tr.appendChild(tdName);

        const tdId = document.createElement('td');
        tdId.className = 'mono';
        tdId.textContent = q.id || '';
        tr.appendChild(tdId);

        const tdStatus = document.createElement('td');
        const badge = document.createElement('span');
        const status = (q.state && q.state.status) ? q.state.status : 'unknown';
        badge.className = statusClass(status);
        badge.textContent = status;
        tdStatus.appendChild(badge);
        tr.appendChild(tdStatus);

        const tdMedias = document.createElement('td');
        tdMedias.textContent = formatMedias(q.state && q.state.medias);
        tr.appendChild(tdMedias);

        const tdActions = document.createElement('td');
        const actions = createActionButtons(q);
        tdActions.appendChild(actions.node);
        tr.appendChild(tdActions);

        tbody.appendChild(tr);

        rowRefs.set(q.id, {
          row: tr,
          statusBadge: badge,
          actionButtons: actions.buttons
        });
      });
      setLastUpdated();
      queues.forEach(updateRowFromQueueState);
    }

    function updateRowFromQueueState(q) {
      const ref = rowRefs.get(q.id);
      if (!ref) return;

      const status = (q.state && q.state.status) ? q.state.status : 'unknown';
      ref.statusBadge.className = statusClass(status);
      ref.statusBadge.textContent = status;

      // block only when actually engaged or queued
      const allowed = new Set((q.state && Array.isArray(q.state.medias)) ? q.state.medias : []);
      const open = isQueueOpen(q);
      const globallyBlocked = isEngaged || visitorQueueState === 'QUEUED';

      Object.entries(ref.actionButtons).forEach(([medium, btn]) => {
        btn.disabled = !open || !allowed.has(medium) || globallyBlocked;
      });
    }

    function renderJsonModal() {
      document.getElementById('jsonDump').textContent = JSON.stringify(lastQueues, null, 2);
    }

    function forceEnableAllRows() {
      lastQueues.forEach(q => {
        const ref = rowRefs.get(q.id);
        if (!ref) return;
        const allowed = new Set((q.state && Array.isArray(q.state.medias)) ? q.state.medias : []);
        const open = isQueueOpen(q);
        Object.entries(ref.actionButtons).forEach(([medium, btn]) => {
          btn.disabled = !(open && allowed.has(medium));
        });
      });
      log('Force-enabled action buttons based on queue openness');
    }

    /* ---------- data flow ---------- */
    function refreshQueues() {
      if (!gliaApi) return Promise.resolve();
      return gliaApi.getQueues().then(queues => {
        lastQueues = queues || [];
        renderTable(lastQueues);
        log('Queues refreshed (' + lastQueues.length + ')');

        const ids = lastQueues.map(q => q.id);
        if (typeof gliaApi.subscribeToQueueStateUpdates === 'function') {
          gliaApi.subscribeToQueueStateUpdates(ids, onQueueState);
        }
      }).catch(err => {
        log('getQueues() failed: ' + (err && err.message ? err.message : err));
      });
    }

    function onQueueState(queue) { updateRowFromQueueState(queue); }

    /* ---------- state listeners ---------- */
    function onVisitorQueueingState(queuingState) {
      try {
        const state = queuingState?.state || '';
        if (state === queuingState.QUEUE_STATES.QUEUED) {
          visitorQueueState = 'QUEUED';
          queueTicket = queuingState.ticket || queueTicket;
          showBanner(`You are queued (reason: ${queuingState?.transitionReason || 'n/a'})`);
          rowRefs.forEach(ref => Object.values(ref.actionButtons).forEach(btn => btn.disabled = true));
        } else if (state === queuingState.QUEUE_STATES.CANNOT_QUEUE) {
          visitorQueueState = 'CANNOT_QUEUE';
          queueTicket = null;
          hideBanner();
          lastQueues.forEach(updateRowFromQueueState);
        } else {
          visitorQueueState = 'CAN_QUEUE';
          queueTicket = null;
          hideBanner();
          lastQueues.forEach(updateRowFromQueueState);
        }
      } catch (e) {
        log('Error handling visitor queueing state: ' + (e?.message || e));
      }
    }

    function onEngagementStart(e) {
      isEngaged = true;
      log('ENGAGEMENT_START');
      rowRefs.forEach(ref => Object.values(ref.actionButtons).forEach(btn => btn.disabled = true));
    }

    function onEngagementEnd(e) {
      isEngaged = false;
      visitorQueueState = 'CAN_QUEUE';
      queueTicket = null;
      hideBanner();
      log('ENGAGEMENT_END — enabling buttons and refreshing queues');

      if (reenableTimer) clearTimeout(reenableTimer);
      reenableTimer = setTimeout(async () => {
        await refreshQueues();
        forceEnableAllRows();
        setTimeout(forceEnableAllRows, 800); // safety pass
      }, 300);
    }

    function attachGlobalListeners(glia) {
      glia.addEventListener(glia.EVENTS.QUEUE_STATE_UPDATE, onVisitorQueueingState);
      glia.addEventListener(glia.EVENTS.ENGAGEMENT_START, onEngagementStart);
      glia.addEventListener(glia.EVENTS.ENGAGEMENT_END, onEngagementEnd);
    }

    /* ---------- modal + DOM controls ---------- */
    function openJsonModal() { renderJsonModal(); document.getElementById('jsonModal').classList.add('show'); }
    function closeJsonModal() { document.getElementById('jsonModal').classList.remove('show'); }

    /* ---------- init ---------- */
    function initializeSalemove() {
      if (typeof sm !== 'undefined' && typeof sm.getApi === 'function') {
        sm.getApi({ version: 'v1' }).then(function(glia) {
          gliaApi = glia;
          log('Salemove API initialized.');

          attachGlobalListeners(glia);
          refreshQueues();

          // Prefill attributes from local cache, then push once on load (optional)
          writeAttrsToForm(loadAttrsFromStorage());

          // example: set a simple custom attribute so we see something in logs
          glia.updateInformation({
            customAttributesUpdateMethod: 'merge',
            customAttributes: { vip: 'true' }
          }).then(function() {
            log('Visitor info updated (customAttributes.vip=true).');
          }).catch(function(error) {
            if (error.cause === glia.ERRORS.NETWORK_TIMEOUT) {
              log('Error: Network timeout while updating visitor info.');
            } else {
              log('Error updating visitor info: ' + error.message);
            }
          });

        }).catch(function(error) {
          log('Error initializing Salemove API: ' + error.message);
        });
      } else {
        log('Salemove API (sm object) not available.');
      }
    }

    window.addEventListener('DOMContentLoaded', function() {
      log('Page fully loaded and DOM is ready.');

      // table controls
      document.getElementById('refreshBtn').addEventListener('click', refreshQueues);
      document.getElementById('viewJsonBtn').addEventListener('click', openJsonModal);
      document.getElementById('closeJsonBtn').addEventListener('click', closeJsonModal);
      document.getElementById('jsonModal').addEventListener('click', (e) => { if (e.target.id === 'jsonModal') closeJsonModal(); });
      window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeJsonModal(); });
      document.getElementById('cancelQueueBtn').addEventListener('click', cancelQueuing);

      // attribute panel
      document.getElementById('saveAttrsBtn').addEventListener('click', saveAttributesToGlia);
      document.getElementById('resetAttrsBtn').addEventListener('click', resetAttributesForm);
    });
  </script>
</body>
</html>
